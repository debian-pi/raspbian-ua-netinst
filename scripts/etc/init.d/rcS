#!/bin/busybox sh

# "read without -r" is only used in the fail function and there we don't care
# what, but only if something is typed indicating there's a keyboard attached
# ready for debugging
# shellcheck disable=SC2162

# "Check exit code directly with e.g. 'if mycmd;', not indirectly with $?"
# IIRC we did that deliberately, so suppress the warning.
# If I/we change that in the future, we can re-enable it then.
# shellcheck disable=SC2181

LOGFILE=/tmp/raspbian-ua-netinst.log

# default options, can be overriden in installer-config.txt
preset=server
packages=
mirror=http://mirrordirector.raspbian.org/raspbian/
release=buster
init_system=systemd
hostname=pi
boot_volume_label=
domainname=
rootpw=raspbian
root_ssh_pubkey=
disable_root=
username=
userpw=
user_ssh_pubkey=
user_is_admin=
cdebootstrap_cmdline=
bootsize=+128M
bootoffset=8192
rootsize=
timeserver=time.nist.gov
timezone=Etc/UTC
locales=
system_default_locale=
disable_predictable_nin=1
ifname=eth0
ip4_addr=dhcp
ip4_prefixlength=0
ip4_gateway=0.0.0.0
ip4_nameservers=
ip6_addr=disable
ip6_prefixlength=0
ip6_gateway=auto
ip6_nameservers=auto
drivers_to_load=
online_config=
usbroot=
cmdline="dwc_otg.lpm_enable=0 console=ttyAMA0,115200 kgdboc=ttyAMA0,115200 console=tty1 elevator=deadline"
rootfstype=ext4
final_action=reboot
hardware_versions=detect
hwrng_support=1
enable_watchdog=0
enable_uart=0
gpu_mem=
try_again=0

# these shouldn't really be changed unless auto-detection fails
bootdev=/dev/mmcblk0
bootpartition=/dev/mmcblk0p1
rootdev=/dev/mmcblk0
rootpartition=

log_msg()
{
    printf '%s\n' "$*"
}

log_msg_start()
{
    printf '%s' "$*"
}

log_msg_inline()
{
    log_msg_start "$*"
}

log_msg_end()
{
    log_msg "$*"
}

fail()
{
    log_msg
    log_msg "Oh noes, something went wrong!"
    log_msg "You have 10 seconds to hit ENTER to get a shell..."

    # copy logfile to /boot/ partition to preserve it.
    # test whether the sd card is still mounted on /boot and if not, mount it.
    if [ ! -f /boot/bootcode.bin ] ; then
        mount $bootpartition /boot
        fail_boot_mounted=true
    fi
    cp -- $LOGFILE /boot/raspbian-ua-netinst-"$(date +%Y%m%dT%H%M%S)".log
    sync

    # if we mounted /boot in the fail command, unmount it.
    if [ "$fail_boot_mounted" = true ] ; then
        umount /boot
    fi
    
    if [ "$try_again" = 1 ] ; then
        read -t 10 || reboot && exit
    else
        read -t 10 || poweroff && exit
    fi
    
    sh
}

sanitize_inputfile()
{
    if [ -z "$1" ]
    then
        log_msg "No input file specified!"
    else
        inputfile=$1
        # convert line endings to unix
        dos2unix "$inputfile"
    fi
}

install_files()
{
  file_to_read="$1"
  log_msg "Adding files & folders listed in /bootfs/config/$file_to_read"
  sanitize_inputfile "/bootfs/config/$file_to_read"
  grep -v "^[[:space:]]*#\|^[[:space:]]*$" "/bootfs/config/${file_to_read}" | while read -r line; do
    owner=$(printf '%s' "$line" | awk '{ print $1 }')
    perms=$(printf '%s' "$line" | awk '{ print $2 }')
    file=$(printf '%s'  "$line" | awk '{ print $3 }')
    log_msg "    $file"
    if [ ! -d "/bootfs/config/files$file" ]; then
      mkdir -p "/rootfs$(dirname "$file")"
      cp "/bootfs/config/files$file" "/rootfs$file"
    else
      mkdir -p "/rootfs/$file"
    fi
    chmod "$perms" "/rootfs$file"
    chroot /rootfs chown "$owner" "$file"
  done
  log_msg
}

setup_chroot()
{
    if [ -d "$1" ]; then
        CHROOT_DIR=$1
        log_msg_start "Setting up chroot in $CHROOT_DIR... "
        mount --bind /proc "$CHROOT_DIR/proc"
        mount --bind /sys "$CHROOT_DIR/sys"
        mount --bind /dev "$CHROOT_DIR/dev"
        mount --bind /dev/pts "$CHROOT_DIR/dev/pts"
        log_msg_end "OK"
    else
        log_msg "'$1' doesn't exist or isn't a directory, so not setting up chroot."
    fi
}

teardown_chroot()
{
    if [ -d "$1" ]; then
        CHROOT_DIR=$1
        log_msg_start "Tearing down chroot in $CHROOT_DIR... "
        umount "$CHROOT_DIR/dev/pts"
        umount "$CHROOT_DIR/dev"
        umount "$CHROOT_DIR/sys"
        umount "$CHROOT_DIR/proc"
        log_msg_end "OK"
    else
        log_msg "'$1' doesn't exist or isn't a directory, so not tearing down chroot."
    fi
}

is_change_in_release()
{
    changedate=$1
    #busybox tr does NOT support [:upper:]/[:lower:] even though it's part of the POSIX standard
    # shellcheck disable=SC2018,SC2019
    release=$(printf '%s' "$2" | tr 'A-Z' 'a-z')

    releasedate=$(awk -F "," -v releasename="$release" '{ if ($3 == releasename) print $5}' /usr/share/distro-info/debian.csv)
    case $releasedate in
        *[![:blank:]]*)
            #valid release date
            ;;
        *)
            #invalid release date, so set it explicitly to null
            releasedate="null"
            ;;
    esac

    #return 1 if there is no release date known (Sid/Testing or (now) Bullseye) OR when releasedate >= changedate
    if [ "$releasedate" = "null" ] || [ "$(printf '%s' "$releasedate" | tr -d -)" -ge "$(printf '%s' "$changedate" | tr -d -)" ] ; then
        log_msg 1
    else
        log_msg 0
    fi

}

show_deprecation_notice()
{
    if [ -z "$1" ]; then
        exit 1
    fi

    log_msg "******************************************************"
    log_msg "                 DEPRECATION NOTICE                   "
    log_msg "******************************************************"

    config_id=$1
    case "$config_id" in
        "ip_addr")
            log_msg "You are using the setting 'ip_addr', but that is deprecated. Please use 'ip4_addr' instead."
            config_change="remove"
        ;;
        "ip_gateway")
            log_msg "You are using the setting 'ip_gateway', but that is deprecated. Please use 'ip4_gateway' instead."
            config_change="remove"
        ;;
        "ip_nameservers")
            log_msg "You are using the setting 'ip_nameservers', but that is deprecated. Please use 'ip4_nameservers' instead."
            config_change="remove"
        ;;
        "ip_netmask")
            log_msg "You are using the setting 'ip_netmask', but that is deprecated. Please use 'ip4_prefixlength' instead."
            config_change="remove"
        ;;
        "preset")
            log_msg "You are using an unknown 'preset', but that is deprecated. Please use 'base', 'minimal' or 'server' instead."
            config_change="remove"
    esac

    case "$config_change" in
        "remove")
            log_msg "In the next major release, this setting will no longer work and the compatibility code will be removed."
            log_msg "Consequently, the installer will probably not do what you want or may fail entirely."
        ;;
    esac

    log_msg "******************************************************"
}

/bin/busybox mkdir -p /opt/busybox/bin/
/bin/busybox --install /opt/busybox/bin/
export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/busybox/bin

mkdir -p /proc
mkdir -p /sys
mkdir -p /boot
mkdir -p /usr/bin
mkdir -p /usr/sbin
mkdir -p /var/run
mkdir -p /etc/raspbian-ua-netinst
mkdir -p /rootfs/boot
mkdir -p /bootfs
mkdir -p /tmp/

ln -s /opt/busybox/bin/sh /bin/sh

# put PATH in /etc/profile so it's also available when we get a busybox shell
printf "%s\n" "export PATH=${PATH}" > /etc/profile

mount -t proc proc /proc
mount -t sysfs sysfs /sys

mount -t tmpfs -o size=64k,mode=0755 tmpfs /dev
mkdir /dev/pts
mount -t devpts devpts /dev/pts

printf "%s\n" /opt/busybox/bin/mdev > /proc/sys/kernel/hotplug
mdev -s

if [ -e /proc/mounts ] ; then
    ln -s /proc/mounts /etc/mtab
else
    log_msg "/proc/mounts doesn't exist (here)"
fi

klogd -c 1

# remove unused drivers from ram disk
for folder in /lib/modules/*; do
    if [ "$(basename "${folder}")" != "$(uname -r)" ]; then
        rm -r "${folder}"
    fi
done

# set screen blank period to an hour unless consoleblank=0 on cmdline
# hopefully the install should be done by then
if grep -qv  "consoleblank=0" /proc/cmdline; then
    printf '\033[9;60]'
fi

# Check if there's an alternative rcS file and excute it
# instead of this file. Only do this if this isn't the
# alternative script already
if [ -z "${am_subscript}" ]; then
    mkdir -p /boot
    mount $bootpartition /boot
    if [ -e /boot/config/installer/rcS ]; then
        cp /boot/config/installer/rcS /rcS
        umount /boot
        log_msg "============================================="
        log_msg "=== Start executing alternative rcS ========="
        log_msg "---------------------------------------------"
        export am_subscript=true
        # shellcheck disable=SC1091   # external file
        . /rcS
        log_msg "---------------------------------------------"
        log_msg "=== Execution of alternative rcS finished ==="
        log_msg "============================================="
        ${final_action} || reboot || exit
    else
        # Clean up, so the rest of the script continues as expected
        umount /boot
    fi
fi

# redirect stdout and stderr also to logfile
# http://stackoverflow.com/questions/3173131/redirect-copy-of-stdout-to-log-file-from-within-bash-script-itself/6635197#6635197
mkfifo ${LOGFILE}.pipe
tee < ${LOGFILE}.pipe $LOGFILE &
exec > ${LOGFILE}.pipe 2>&1
rm ${LOGFILE}.pipe

# we should do this with bitshift operations, I think on the serial
# http://elinux.org/RPi_HardwareHistory#Board_Revision_History
# https://www.raspberrypi.org/documentation/hardware/raspberrypi/revision-codes/README.md
cpu_revision=$(grep Revision /proc/cpuinfo | cut -d " " -f 2 | sed 's/^1000//')
case $cpu_revision in
    900092|900093|9000c1|920092|920093)
        rpi_hardware_version="0"
        ;;
    0002|0003|0004|0005|0006|0007|0008|0009|000d|000e|000f|0010|0012|0013|0015|900021|900032)
        rpi_hardware_version="1"
        ;;
    a01040|a01041|a21041|a22042)
        rpi_hardware_version="2"
        ;;
    9020e0|a02082|a020d3|a22082|a22083|a32082|a52082)
        rpi_hardware_version="3"
        ;;
    a03111|b03111|c03111)
        rpi_hardware_version="4"
        ;;
    *)
        rpi_hardware_version="unknown"
        ;;
esac

log_msg ""
log_msg "================================================="
log_msg "raspbian-ua-netinst"
log_msg "================================================="
log_msg "__VERSION__"
log_msg "Built on __DATE__"
log_msg "Running on Raspberry Pi version ${rpi_hardware_version}"
log_msg "================================================="
log_msg "https://github.com/debian-pi/raspbian-ua-netinst/"
log_msg "================================================="

log_msg_start "Starting HWRNG "
modprobe bcm2835-rng
/usr/sbin/rngd -r /dev/hwrng
if [ $? -eq 0 ]; then
    log_msg_end "succeeded!"
else
    log_msg_end "FAILED! (continuing to use the software RNG)"
fi

log_msg_start "Copying boot files... "
# copy boot data to safety
mount $bootpartition /boot || fail

cp -r -- /boot/* /bootfs/ || fail

umount /boot || fail
log_msg_end "OK"

if [ -e /bootfs/installer-config.txt ]; then
    log_msg "================================================="
    log_msg "=== Start executing installer-config.txt. ==="
    sanitize_inputfile /bootfs/installer-config.txt
    # shellcheck disable=SC1091   # external file
    . /bootfs/installer-config.txt
    log_msg "=== Finished executing installer-config.txt. ==="
    log_msg "================================================="
fi

if [ -e /bootfs/config/wpa_supplicant.conf ]; then
    sanitize_inputfile /bootfs/config/wpa_supplicant.conf
fi

# Provide backwards compatibility for v1.0 configurations which used
# "ip_" prefix instead of "ip4_"

# shellcheck disable=SC2154  # deprecated var name
if [ -n "$ip_addr" ]; then
    ip4_addr="$ip_addr"
    show_deprecation_notice "ip_addr"
fi

# shellcheck disable=SC2154  # deprecated var name
if [ -n "$ip_gateway" ]; then
    ip4_gateway="$ip_gateway"
    show_deprecation_notice "ip_gateway"
fi

# shellcheck disable=SC2154  # deprecated var name
if [ -n "$ip_nameservers" ]; then
    ip4_nameservers="$ip_nameservers"
    show_deprecation_notice "ip_nameservers"
fi

# Provide backwards compatibility for v1.0 configurations which used
# "ip_netmask" instead of "ip4_prefixlength"

# shellcheck disable=SC2154  # deprecated var name
if [ -n "$ip_netmask" ]; then
    ip4_prefixlength=$(ipcalc -p 255.255.255.255 "$ip_netmask" | cut -d= -f2)
    show_deprecation_notice "ip_netmask"
fi

log_msg
log_msg "Network configuration:"
log_msg "  ip4_addr = $ip4_addr"

if [ "$ip4_addr" = "disable" ]; then
    # nothing to do, just pass
    :
elif [ "$ip4_addr" != "dhcp" ]; then
    log_msg "  ip4_prefixlength = $ip4_prefixlength"
    log_msg "  ip4_gateway = $ip4_gateway"
    log_msg "  ip4_nameservers = $ip4_nameservers"
fi

log_msg "  ip6_addr = $ip6_addr"

if [ "$ip6_addr" = "disable" ]; then
    # nothing to do, just pass
    :
elif [ "$ip6_addr" = "auto" ]; then
    log_msg "  ip6_nameservers = $ip6_nameservers"
else
    log_msg "  ip6_prefixlength = $ip6_prefixlength"
    log_msg "  ip6_gateway = $ip6_gateway"
    log_msg "  ip6_nameservers = $ip6_nameservers"
fi

log_msg "  online_config = $online_config"
log_msg

# depmod needs to update modules.dep before using modprobe
depmod -a

# coldplug modules
log_msg "Loading drivers."
find /sys/ -name modalias -print0 | xargs -0 sort -u -z | xargs -0 modprobe -abq
log_msg "Finished loading drivers."

if [ "$drivers_to_load" != "" ] ; then
   log_msg "Loading additional drivers."
   for driver in $drivers_to_load
   do
      log_msg_start " Loading driver '$driver' ... "
      modprobe "$driver" || fail
      log_msg_end "OK"
   done
   log_msg "Finished loading additional drivers"
fi

log_msg_start "Waiting for $ifname... "

for i in $(seq 1 10); do

    ifconfig $ifname 1>/dev/null 2>&1
    if [ $? -eq 0 ]; then
        log_msg_end "OK"
        break
    fi

    if [ "$i" -eq 10 ]; then
        log_msg_end "FAILED"
        fail
    fi

    sleep 1

    log_msg_inline "$i.. "
done

if [ "$ifname" != "eth0" ]; then
    # Replace eth0 as udhcpc dns interface
    sed -i "s/PEERDNS_IF=.*/PEERDNS_IF=$ifname/g" /etc/udhcpc/default.script
    # if eth0 is not the chosen eth interface it is a wireless interface and wpa_supplicant must connect to wlan
    log_msg "Starting wpa_supplicant... "
    wpa_supplicant -B -Dnl80211 -c/bootfs/config/wpa_supplicant.conf -i$ifname
    if [ $? -ne 0 ]; then
        log_msg "nl80211 driver didn't work. Trying generic driver (wext)..."
        wpa_supplicant -B -Dwext -c/bootfs/config/wpa_supplicant.conf -i$ifname || fail
        log_msg "Connection with wext succeeded."
    fi
fi

# do some IPv6 configuration which must be done before the
# network interface is brought up
if [ "$ip6_addr" != "disable" ]; then
    modprobe ipv6
    if [ "$ip6_addr" != "auto" ]; then
        if [ "$ip6_gateway" != "auto" ]; then
            # disable the acceptance of incoming Router Advertisement (RA)
            # messages, otherwise the kernel might automatically add routes
            printf '%d' 0 > /proc/sys/net/ipv6/conf/$ifname/accept_ra
        else
            # disable automatic generation of IPv6 addresses, which the kernel
            # will do when it receives a suitable RA
            printf '%d' 0 > /proc/sys/net/ipv6/conf/$ifname/autoconf
	fi
    fi
fi

ip link set lo up
ip link set $ifname up

touch /etc/resolv.conf
if [ "$ip4_addr" = "disable" ]; then
    # if IPv4 is disabled, configure the DNS resolver in glibc
    # to prefer IPv6 addresses (by performing AAAA lookups
    # before A lookups)
    printf '%s' "options inet6" >> /etc/resolv.conf
elif [ "$ip4_addr" = "dhcp" ]; then
    log_msg_start "Configuring $ifname for IPv4 using DHCP... "

    udhcpc -i $ifname 1>/dev/null 2>&1
    if [ $? -eq 0 ]; then
        have_ip4=$(ip -4 addr ls $ifname | grep 'scope global' | awk '{print $2}')
	    log_msg_end "$have_ip4"
    else
        log_msg_end "FAILED"
    fi
else
    log_msg_start "Configuring $ifname for IPv4 using static $ip4_addr... "
    ip addr add "$ip4_addr"/"$ip4_prefixlength" dev $ifname || fail
    ip route add default via "$ip4_gateway" || fail
    for i in $ip4_nameservers; do
        printf "nameserver %s" "$i" >> /etc/resolv.conf
    done
    have_ip4=$ip4_addr
    log_msg_end "OK"
fi

if [ "$ip6_addr" != "disable" ]; then
    log_msg_start "Waiting for IPv6 link-local address on $ifname... "

    for i in $(seq 1 10); do
        if ip -6 addr show dev $ifname scope link | grep -q 'scope link'; then
            break
        fi

        if [ "$i" -eq 10 ]; then
            log_msg_end "FAILED"
            fail
        fi

        sleep 1

        log_msg_inline "$i.. "
    done

    # ensure that the IPv6 stack is ready; race conditions are fun!
    sleep 2
    log_msg_end "OK"
    rdisc6 $ifname > /tmp/ip6_ra
    # the 'awk' usage below is to trim whitespace around the value
    ip6_ra_m=$(grep 'Stateful address' /tmp/ip6_ra | cut -d: -f2- | awk '{$1=$1};1')
    if [ "$ip6_ra_m" = "Yes" ]; then
        log_msg "IPv6 on this network is provided by DHCPv6, but this installer does not support DHCPv6."
        log_msg "IPv6 will be disabled."
        ip6_addr=disable
    fi
    # the 'awk' usage below is to trim whitespace around the value
    ip6_ra_o=$(grep 'Stateful other' /tmp/ip6_ra | cut -d: -f2- | awk '{$1=$1};1')
    if [ "$ip6_ra_o" = "Yes" ]; then
        log_msg "IPv6 DNS and other information on this network is provided by DHCPv6, but this installer does not support DHCPv6."
        log_msg "IPv6 will be disabled."
        ip6_addr=disable
    fi
fi

if [ "$ip6_addr" = "disable" ]; then
    # nothing to do, just pass
    :
elif [ "$ip6_addr" = "auto" ]; then
    log_msg_start "Configuring $ifname for IPv6 using SLAAC... "

    for i in $(seq 1 10); do
        ip -6 addr ls $ifname | grep -q 'scope global'
        if [ $? -eq 0 ]; then
            have_ip6=$(ip -6 addr ls $ifname | grep 'scope global' | awk '{print $2}')
            log_msg_end "$have_ip6"
            break
        fi

        if [ "$i" -eq 10 ]; then
            log_msg_end "FAILED"
        fi

        sleep 1

        log_msg_inline "$i.. "
    done
else
    log_msg_start "Configuring $ifname for IPv6 using static $ip6_addr... "
    ip addr add "$ip6_addr"/"$ip6_prefixlength" dev $ifname || fail
    if [ "$ip6_gateway" != "auto" ]; then
        ip route add default via "$ip6_gateway" || fail
    fi
    have_ip6=$ip6_addr
    log_msg_end "OK"
fi

if [ -n "$have_ip6" ]; then
    if [ "$ip6_nameservers" = "auto" ]; then
        log_msg_start "Obtaining IPv6 recursive DNS server address(es) via RDNSS... "
        have_ip6_nameservers=$(grep 'Recursive DNS' /tmp/ip6_ra | cut -d: -f2-)
        if [ -z "$have_ip6_nameservers" ]; then
            log_msg_end "FAILED"
        else
            log_msg_end "$have_ip6_nameservers"
        fi
    elif [ "$ip6_nameservers" != "disable" ]; then
        have_ip6_nameservers=$ip6_nameservers
    fi
    if [ -n "$have_ip6_nameservers" ]; then
        for i in $have_ip6_nameservers; do
            printf "nameserver %s" "$i" >> /etc/resolv.conf
        done
    fi
    log_msg_end "OK"
fi

if [ -z "$have_ip4" ] && [ -z "$have_ip6" ]; then
    log_msg "No IPv4 or IPv6 addresses were configured or obtained. Installation cannot continue."
    fail
fi

# This will record the time to get to this point
PRE_NETWORK_DURATION=$(date +%s)

date_set=false
if [ "$date_set" = "false" ] ; then
    # set time with ntpdate
    ntpdate-debian -b 1>/dev/null 2>&1
    if [ $? -eq 0 ] ; then
        log_msg_start "Time set using ntpdate to... "
        date
        date_set=true
    else
        log_msg "Failed to set time using ntpdate!"
    fi

    if [ "$date_set" = "false" ] ; then
        # failed to set time with ntpdate, fall back to rdate
        # time server addresses taken from http://tf.nist.gov/tf-cgi/servers.cgi
        timeservers=$timeserver
        timeservers="$timeservers time.nist.gov nist1.symmetricom.com"
        timeservers="$timeservers nist-time-server.eoni.com utcnist.colorado.edu"
        timeservers="$timeservers nist1-pa.ustiming.org nist.expertsmi.com"
        timeservers="$timeservers nist1-macon.macon.ga.us wolfnisttime.com"
        timeservers="$timeservers nist.time.nosc.us nist.netservicesgroup.com"
        timeservers="$timeservers nisttime.carsoncity.k12.mi.us nist1-lnk.binary.net"
        timeservers="$timeservers ntp-nist.ldsbc.edu utcnist2.colorado.edu"
        timeservers="$timeservers nist1-ny2.ustiming.org wwv.nist.gov"
        for ts in $timeservers
        do
            rdate "$ts" 1>/dev/null 2>&1
            if [ $? -eq 0 ]; then
                log_msg_start "Time set using timeserver '$ts' to... "
                date
                date_set=true
                break
            else
                log_msg "Failed to set time using timeserver '$ts'."
            fi
        done
    fi
fi
if [ "$date_set" = "false" ] ; then
    log_msg "FAILED to set the date, so things are likely to fail now ..."
    log_msg "Make sure that rdate port 37 is not blocked by your firewall."
fi

# Record the time now that the time is set to a correct value
STARTTIME=$(date +%s)
# And substract the PRE_NETWORK_DURATION from STARTTIME to get the
# REAL starting time.
REAL_STARTTIME=$((STARTTIME - PRE_NETWORK_DURATION))
log_msg ""
log_msg "Installation started at $(date --date="@$REAL_STARTTIME" --utc)."
log_msg ""

if [ "$online_config" != "" ]; then
    log_msg_start "Downloading online config from $online_config... "
    curl -L --silent -o /online-config.txt "$online_config" 1>/dev/null 2>&1 || fail
    log_msg_end "OK"

    log_msg "================================================="
    log_msg "=== Start executing online-config.txt. ==="
    sanitize_inputfile /online-config.txt
    # shellcheck disable=SC1091   # external file
    . /online-config.txt
    log_msg "=== Finished executing online-config.txt. ==="
    log_msg "================================================="
fi

if [ "$hardware_versions" = "detect" ]; then
    case $rpi_hardware_version in
        0) hardware_versions="0" ;;
        1) hardware_versions="1" ;;
        2) hardware_versions="2" ;;
        3) hardware_versions="3" ;;
        4) hardware_versions="4" ;;
        *)
           log_msg ""
           log_msg "================================================="
           log_msg "     No Raspberry Pi hardware detected!!"
           log_msg " Value of cpu_revision variable: '${cpu_revision}'"
           log_msg "        Building for Pi 0, 1, 2, 3 and 4."
           log_msg "================================================="
           log_msg ""
           hardware_versions="0 1 2 3 4"
           ;;
    esac
fi

# prepare rootfs mount options
case "$rootfstype" in
  "btrfs")
    rootfs_mkfs_options=${rootfs_mkfs_options:-'-f'}
    rootfs_install_mount_options=${rootfs_install_mount_options:-'noatime'}
    rootfs_mount_options=${rootfs_mount_options:-'noatime'}
    ;;
  "ext4")
    rootfs_mkfs_options=${rootfs_mkfs_options:-''}
    rootfs_install_mount_options=${rootfs_install_mount_options:-'noatime,data=writeback,nobarrier,noinit_itable'}
    rootfs_mount_options=${rootfs_mount_options:-'errors=remount-ro,noatime'}
    ;;
  "f2fs")
    rootfs_mkfs_options=${rootfs_mkfs_options:-'-f'}
    rootfs_install_mount_options=${rootfs_install_mount_options:-'noatime'}
    rootfs_mount_options=${rootfs_mount_options:-'noatime'}
    ;;
  *)
    log_msg "Unknown filesystem specified: $rootfstype"
    fail
    ;;
esac

# check if we need to install wpasupplicant package
if [ "$ifname" != "eth0" ]; then
    if [ -z "$packages" ]; then
        packages="wpasupplicant"
    else
        packages="$packages,wpasupplicant"
    fi
fi

# check if we need the sudo package and add it if so
if [ "$user_is_admin" = "1" ]; then
    if [ -z "$packages" ]; then
        packages="sudo"
    else
        packages="$packages,sudo"
    fi
fi

# configure different kinds of presets
if [ "$cdebootstrap_cmdline" = "" ]; then

    # from small to large: base, minimal, server
    # not very logical that minimal > base, but that's how it was historically defined

    # base
    base_packages="cpufrequtils,kmod"

    for hv in ${hardware_versions}
    do
        case $hv in
            0|1) kernel_meta_package=linux-image-rpi-rpfv ;;
            2|3|4) kernel_meta_package=linux-image-rpi2-rpfv ;;
            *)
                log_msg ""
                log_msg "================================================="
                log_msg "  I don't understand a hardware version of ${hv} "
                log_msg "    Skipping the kernel work for that hardware.  "
                log_msg "================================================="
                log_msg ""

                kernel_meta_package=none ;;
        esac

        # shellcheck disable=SC2086  # overkill as 'hv' is only a number 0-4
        eval kernel_meta_package_${hv}=${kernel_meta_package}
        if [ ${kernel_meta_package} != "none" ] ; then
            base_packages="${kernel_meta_package},${base_packages}"
        fi
    done

    if [ "$init_system" = "systemd" ] ; then
        base_packages="${base_packages},systemd-sysv"
        base_packages="${base_packages},libpam-systemd"
    elif [ "$init_system" = "sysvinit" ] ; then
        base_packages="${base_packages},sysvinit-core"
    elif [ "$init_system" = "runit" ] ; then
        base_packages="${base_packages},runit-init"
    fi

    if [ "$hwrng_support" = "1" ]; then
      base_packages="${base_packages},rng-tools"
    fi

    filesystem_packages="dosfstools"
    if [ "$rootfstype" = "ext4" ]; then
        filesystem_packages="${filesystem_packages},e2fsprogs"
    elif [ "$rootfstype" = "f2fs" ]; then
        filesystem_packages="${filesystem_packages},f2fs-tools"
    elif [ "$rootfstype" = "btrfs" ]; then
        filesystem_packages="${filesystem_packages},btrfs-progs"
    fi
    base_packages="${base_packages},${filesystem_packages}"

    # minimal
    minimal_packages="fake-hwclock,ifupdown,net-tools,ntp,openssh-server,resolvconf"
    if [ -n "$have_ip6" ] && [ "$ip6_nameservers" = "auto" ]; then
        minimal_packages="${minimal_packages},rdnssd"
    fi

    # server
    server_packages="vim-tiny,iputils-ping,wget,ca-certificates,rsyslog,cron,dialog,locales,less,man-db"

    case $preset in
        base)
            cdebootstrap_cmdline="--flavour=minimal --include=${base_packages}"
            ;;
        minimal)
            cdebootstrap_cmdline="--flavour=minimal --include=${base_packages},${minimal_packages}"
            ;;
        *)
            # this should be 'server', but using '*' for backward-compatibility
            cdebootstrap_cmdline="--flavour=minimal --include=${base_packages},${minimal_packages},${server_packages}"
            if [ "$preset" != "server" ]; then
                show_deprecation_notice "preset"
                log_msg "Using 'server' as fallback preset"
            fi
            ;;
    esac

    dhcp_client_package="isc-dhcp-client"
    # add IPv4 DHCP client if needed
    if [ "$ip4_addr" = "dhcp" ]; then
        cdebootstrap_cmdline="${cdebootstrap_cmdline},${dhcp_client_package}"
    fi

    # add user defined packages
    if [ "$packages" != "" ]; then
        cdebootstrap_cmdline="${cdebootstrap_cmdline},${packages}"
    fi

else
    preset=none
fi

if [ "$usbroot" = "1" ]; then
    rootdev=/dev/sda
    log_msg_start "Loading USB modules... "
    # only do modprobe if the module is NOT built into the kernel
    if [ "$(grep -c "sd_mod" /lib/modules/"$(uname -r)"/modules.builtin)" -eq 0 ]; then
        modprobe sd_mod 1>/dev/null 2>&1 || fail
    fi
    if [ "$(grep -c "usb-storage" /lib/modules/"$(uname -r)"/modules.builtin)" -eq 0 ]; then
        modprobe usb-storage 1>/dev/null 2>&1 || fail
    fi
    log_msg_end "OK"
fi

if [ "$rootpartition" = "" ]; then
    if [ "$rootdev" = "/dev/sda" ]; then
        rootpartition=/dev/sda1
    else
        rootpartition=/dev/mmcblk0p2
    fi
fi

log_msg
log_msg "Installer configuration:"
log_msg "  preset = $preset"
log_msg "  packages = $packages"
log_msg "  mirror = $mirror"
log_msg "  release = $release"
log_msg "  init_system = $init_system"
log_msg "  hostname = $hostname"
log_msg "  domainname = $domainname"
log_msg "  rootpw = $rootpw"
log_msg "  root_ssh_pubkey = $root_ssh_pubkey"
log_msg "  disable_root = $disable_root"
log_msg "  username = $username"
log_msg "  userpw = $userpw"
log_msg "  user_ssh_pubkey = $user_ssh_pubkey"
log_msg "  user_is_admin = $user_is_admin"
log_msg "  cdebootstrap_cmdline = $cdebootstrap_cmdline"
log_msg "  boot_volume_label = $boot_volume_label"
log_msg "  bootsize = $bootsize"
log_msg "  bootoffset = $bootoffset"
log_msg "  rootsize = $rootsize"
log_msg "  timeserver = $timeserver"
log_msg "  timezone = $timezone"
log_msg "  locales = $locales"
log_msg "  system_default_locale = $system_default_locale"
log_msg "  cmdline = $cmdline"
log_msg "  usbroot = $usbroot"
log_msg "  rootdev = $rootdev"
log_msg "  rootpartition = $rootpartition"
log_msg "  rootfstype = $rootfstype"
log_msg "  rootfs_mkfs_options = $rootfs_mkfs_options"
log_msg "  rootfs_install_mount_options = $rootfs_install_mount_options"
log_msg "  rootfs_mount_options = $rootfs_mount_options"
log_msg "  final_action = $final_action"
log_msg "  hardware_versions = $hardware_versions"
log_msg "  gpu_mem = $gpu_mem"
log_msg

log_msg_start "Waiting 5 seconds"
for i in $(seq 1 5); do
    log_msg_inline "."
    sleep 1
done
log_msg_end

# fdisk's boot offset is 2048, so only handle $bootoffset is it's larger then that
if [ -n "$bootoffset" ] && [ "$bootoffset" -gt 2048 ] ; then
    emptyspaceend=$((bootoffset - 1))
else
    emptyspaceend=
fi

# Create a file for partitioning sd card only
FDISK_SCHEME_SD_ONLY=/etc/raspbian-ua-netinst/fdisk-sd-only.config
touch $FDISK_SCHEME_SD_ONLY
{
    if [ -n "$emptyspaceend" ] ; then
        # we have a custom bootoffset, so first create a temporary
        # partition occupying the space before it.
        # We'll remove it before committing the changes again.
        printf '%s\n' "n"
        printf '%s\n' "p"
        printf '%s\n' "4"
        printf '%s\n' ""
        printf '%s\n' "$emptyspaceend"
    fi
    printf '%s\n' "n"
    printf '%s\n' "p"
    printf '%s\n' "1"
    printf '%s\n' ""
    printf '%s\n' "$bootsize"
    printf '%s\n' "t"
    if [ -n "$emptyspaceend" ] ; then
        # because we now have more then 1 partition
        # we need to select the one to operate on
        printf '%s\n' "1"
    fi
    printf '%s\n' "b"
    printf '%s\n' "n"
    printf '%s\n' "p"
    printf '%s\n' "2"
    printf '%s\n' ""
    printf '%s\n' "$rootsize"
    if [ -n "$emptyspaceend" ] ; then
        # now remove the temporary partition again
        printf '%s\n' "d"
        printf '%s\n' "4"
    fi
    printf '%s\n' "w"
} >> ${FDISK_SCHEME_SD_ONLY}

# Create a file for partitioning when only /boot/ is on sd card
FDISK_SCHEME_SD_BOOT=/etc/raspbian-ua-netinst/fdisk-sd-boot.config
touch $FDISK_SCHEME_SD_BOOT
{
    if [ -n "$emptyspaceend" ] ; then
        # we have a custom bootoffset, so first create a temporary
        # partition occupying the space before it.
        # We'll remove it before committing the changes again.
        printf '%s\n' "n"
        printf '%s\n' "p"
        printf '%s\n' "4"
        printf '%s\n' ""
        printf '%s\n' "$emptyspaceend"
    fi
    printf '%s\n' "n"
    printf '%s\n' "p"
    printf '%s\n' "1"
    printf '%s\n' ""
    printf '%s\n' "$bootsize"
    printf '%s\n' "t"
    if [ -n "$emptyspaceend" ] ; then
        # because we now have more then 1 partition
        # we need to select the one to operate on
        printf '%s\n' "1"
    fi
    printf '%s\n' "b"
    if [ -n "$emptyspaceend" ] ; then
        # now remove the temporary partition again
        printf '%s\n' "d"
        printf '%s\n' "4"
    fi
    printf '%s\n' "w"
} >> ${FDISK_SCHEME_SD_BOOT}

# Create a file for partitioning when / is on usb
FDISK_SCHEME_USB_ROOT=/etc/raspbian-ua-netinst/fdisk-usb-root.config
touch $FDISK_SCHEME_USB_ROOT
{
    printf '%s\n' "n"
    printf '%s\n' "p"
    printf '%s\n' "1"
    printf '%s\n' ""
    printf '%s\n' "$rootsize"
    printf '%s\n' "w"
} >> ${FDISK_SCHEME_USB_ROOT}


log_msg_start "Waiting for $rootdev... "
for i in $(seq 1 10); do

    if [ "$(fdisk -l $rootdev 2>&1 | grep -F Disk)" != "" ]; then
        log_msg_end "OK"
        break
    fi

    if [ "$i" -eq 10 ]; then
        log_msg_end "FAILED"
        fail
    fi

    sleep 1

    log_msg_inline "$i.. "
done

if [ "$rootdev" = "$bootdev" ]; then
    log_msg_start "Applying new partition table... "
    dd if=/dev/zero of=$bootdev bs=512 count=1 1>/dev/null 2>&1
    fdisk $bootdev 1>/dev/null 2>&1 < ${FDISK_SCHEME_SD_ONLY}
    log_msg_end "OK"
else
    log_msg_start "Applying new partition table for $bootdev... "
    dd if=/dev/zero of=$bootdev bs=512 count=1 1>/dev/null 2>&1
    fdisk $bootdev 1>/dev/null 2>&1 < ${FDISK_SCHEME_SD_BOOT}
    log_msg_end "OK"

    log_msg_start "Applying new partition table for $rootdev... "
    dd if=/dev/zero of=$rootdev bs=512 count=1 1>/dev/null 2>&1
    fdisk $rootdev 1>/dev/null 2>&1 < ${FDISK_SCHEME_USB_ROOT}
    log_msg_end "OK"
fi

# refresh the /dev device nodes
mdev -s

log_msg_start "Initializing /boot as vfat... "
if [ "$boot_volume_label" = "" ]; then
  mkfs.vfat $bootpartition 1>/dev/null 2>&1 || fail
else
  mkfs.vfat -n "$boot_volume_label" $bootpartition 1>/dev/null 2>&1 || fail
fi
log_msg_end "OK"

log_msg_start "Copying /boot files in... "
mount $bootpartition /boot || fail
cp -r -- /bootfs/* /boot || fail
sync
umount /boot || fail
log_msg_end "OK"

# only do modprobe if the module is NOT built into the kernel
if [ "$(grep -c $rootfstype /lib/modules/"$(uname -r)"/modules.builtin)" -eq 0 ]; then
    log_msg_start "Loading $rootfstype module... "
    modprobe $rootfstype 1>/dev/null 2>&1 || fail
    log_msg_end "OK"
fi

log_msg_start "Initializing / as $rootfstype... "
# shellcheck disable=SC2086   # quoting it causes failure
mkfs.$rootfstype $rootfs_mkfs_options $rootpartition 1>/dev/null 2>&1 || fail
log_msg_end "OK"

log_msg_start "Mounting new filesystems... "
mount $rootpartition /rootfs -o "$rootfs_install_mount_options" || fail
mkdir /rootfs/boot || fail
mount $bootpartition /rootfs/boot || fail
log_msg_end "OK"

log_msg "Starting install process..."
# With 'cdebootstrap_cmdline we're actually using the word splitting what SC2086 warns us against
# This should probably be fixed at some point, but not in this run/branch.
# shellcheck disable=SC2086
cdebootstrap-static --arch=armhf $cdebootstrap_cmdline "$release" /rootfs $mirror --keyring=/usr/share/keyrings/raspbian-archive-keyring.gpg || fail

log_msg "Configuring installed system:"

setup_chroot /rootfs

# configure root login
if [ ! "$disable_root" = "1" ]; then
    # add SSH key for root (if provided)
    if [ -n "$root_ssh_pubkey" ]; then
        log_msg_start "  Setting root SSH key... "
        mkdir -p /rootfs/root/.ssh || fail
        chmod 0700 /rootfs/root/.ssh || fail
        printf '%s\n' "$root_ssh_pubkey" > /rootfs/root/.ssh/authorized_keys || fail
        log_msg_end "OK"
        log_msg_start "  Setting permissions on root SSH authorized_keys... "
        chmod 600 /rootfs/root/.ssh/authorized_keys || fail
        log_msg_end "OK"
    fi
    if [ -n "$rootpw" ]; then
        # openssh-server since 2014-03-28 (jessie+) doesn't allow root to login with a password
        root_pw_ssh_hack_needed=$(is_change_in_release "2014-03-28" "$release")
        if [ "$root_pw_ssh_hack_needed" = "1" ] && [ -f /rootfs/etc/ssh/sshd_config ] ; then
            log_msg_start "  Allowing root to login with password on $release... "
            sed -i -E 's/PermitRootLogin (without|prohibit)-password/PermitRootLogin yes/' /rootfs/etc/ssh/sshd_config || fail
            sed -i 's/^#PermitRootLogin/PermitRootLogin/' /rootfs/etc/ssh/sshd_config || fail
            log_msg_end "OK"
        fi
        log_msg_start "  Setting root password... "
        printf '%s' "root:$rootpw" | chroot /rootfs /usr/sbin/chpasswd 1>/dev/null 2>&1 || fail
        log_msg_end "OK"
    fi
fi

# add user to system
if [ -n "$username" ]; then
    log_msg_start "  Creating $username user... "
    chroot /rootfs /usr/sbin/adduser "$username" --gecos "" --disabled-password 1>/dev/null 2>&1 || fail
    log_msg_end "OK"
    # add SSH key for user (if provided)
    if [ -n "$user_ssh_pubkey" ]; then
        log_msg_start "  Setting $username SSH key... "
        ssh_dir="/rootfs/home/$username/.ssh"
        mkdir -p "$ssh_dir" || fail
        chmod 0700 "$ssh_dir" || fail
        printf '%s\n' "$user_ssh_pubkey" > "$ssh_dir/authorized_keys" || fail
        log_msg_end "OK"
        log_msg_start "  Setting owner as $username on SSH directory... "
        chroot /rootfs /bin/chown -R "$username:$username" "/home/$username/.ssh" 1>/dev/null 2>&1 || fail
        log_msg_end "OK"
        log_msg_start "  Setting permissions on $username SSH authorized_keys... "
        chmod 600 "$ssh_dir/authorized_keys" || fail
        log_msg_end "OK"
    fi
    if [ -n "$userpw" ]; then
        log_msg_start "  Setting $username password... "
        printf '%s' "$username:$userpw" | chroot /rootfs /usr/sbin/chpasswd 1>/dev/null 2>&1 || fail
        log_msg_end "OK"
    fi
    if [ "$user_is_admin" = "1" ]; then
        log_msg_start "  Adding $username to sudo group... "
        chroot /rootfs /usr/sbin/usermod -aG sudo "$username" 1>/dev/null 2>&1 || fail
        log_msg_end "OK"
        if [ -z "$userpw" ]; then
            log_msg_start "  Setting $username to sudo without a password... "
            printf '%s\n' "$username ALL = (ALL) NOPASSWD: ALL" > "/rootfs/etc/sudoers.d/$username" || fail
            log_msg_end "OK"
        fi
    fi
fi

# default mounts
log_msg_start "  Configuring /etc/fstab... "
touch /rootfs/etc/fstab || fail
{
    printf '%s\n' "$bootpartition /boot vfat defaults 0 2"
    printf '%s\n' "$rootpartition / $rootfstype $rootfs_mount_options 0 1"
    # also specify /tmp on tmpfs in /etc/fstab so it works across init systems
    printf '%s\n' "tmpfs /tmp tmpfs defaults,nodev,nosuid 0 0"
} >> /rootfs/etc/fstab || fail
log_msg_end "OK"

# default hostname
log_msg_start "  Configuring hostname... "
printf '%s\n' $hostname > /rootfs/etc/hostname || fail
# Tell the kernel what the hostname is supposed to be
hostname $hostname
log_msg_end "OK"

log_msg "  Configuring hosts file... "
rm /rootfs/etc/hosts
# Add localhost to hosts
log_msg_start "    adding localhost... "
printf '%s\n' "127.0.0.1 localhost" >> /rootfs/etc/hosts || fail
if [ -n "$have_ip6" ]; then
    printf '%s\n' "::1 localhost" >> /rootfs/etc/hosts || fail
fi
log_msg_end "done."

# Create appropriate hostname entries for IPv4
if [ -n "$have_ip4" ]; then
    if [ "$ip4_addr" = "dhcp" ]; then
        hostfile_addr=127.0.1.1
    else
        hostfile_addr=$ip4_addr
    fi
    if [ "$domainname" = "" ]; then
        log_msg_start "    adding ${hostname} for IPv4... "
        printf '%s\n' "${hostfile_addr} ${hostname}" >> /rootfs/etc/hosts || fail
    else
        log_msg_start "    adding ${hostname}.${domainname} for IPv4... "
        printf '%s\n' "${hostfile_addr} ${hostname}.${domainname} ${hostname}" >> /rootfs/etc/hosts || fail
    fi
    log_msg_end "done."
fi

# Create appropriate hostname entries for IPv6
if [ -n "$have_ip6" ] && [ "$ip6_addr" != "auto" ]; then
    if [ "$domainname" = "" ]; then
        log_msg_start "    adding ${hostname} for IPv6... "
        printf '%s\n' "${ip6_addr} ${hostname}" >> /rootfs/etc/hosts || fail
    else
        log_msg_start "    adding ${hostname}.${domainname} for IPv6... "
        printf '%s\n' "${ip6_addr} ${hostname}.${domainname} ${hostname}" >> /rootfs/etc/hosts || fail
    fi
    log_msg_end "done."
fi

log_msg "  Configuring hosts file completed."

# networking
if [ "$preset" != "base" ]; then
    log_msg_start "  Configuring network settings... "

    if [ "$ip4_addr" = "disable" ]; then
        # if IPv4 is disabled, configure the DNS resolver in glibc
        # to prefer IPv6 addresses (by performing AAAA lookups
        # before A lookups); since resolvconf is installed, this is
        # done by adding the proper line to the resolvconf 'head'
        printf '%s\n' "options inet6" >> /etc/resolvconf/resolv.conf.d/head
    fi

    if [ "$ip6_addr" = "disable" ]; then
        printf '%s\n' net.ipv6.conf.all.disable_ipv6=1 > /rootfs/etc/sysctl.d/disable_ipv6.conf
    fi

    touch /rootfs/etc/network/interfaces || fail
    # lo interface may already be there, so first check for it
    if ! grep -q "auto lo" /rootfs/etc/network/interfaces; then
    {
        printf '%s\n' "auto lo"
        printf '%s\n' "iface lo inet loopback"
    } >> /rootfs/etc/network/interfaces
    fi

    {
        # configured interface
        printf '%s\n' ""
        printf '%s\n' "auto $ifname"
        printf '%s\n' "allow-hotplug $ifname"

        if [ "$ip4_addr" = "disable" ]; then
            # nothing to do, just pass
            :
        elif [ "$ip4_addr" = "dhcp" ]; then
            printf '%s\n' "iface $ifname inet dhcp"
        else
            printf '%s\n' "iface $ifname inet static"
            printf '%s\n' "    address $ip4_addr/$ip4_prefixlength"
            printf '%s\n' "    gateway $ip4_gateway"
            printf '%s\n' "    dns-nameservers $ip4_nameservers"
        fi

        if [ "$ip6_addr" = "disable" ]; then
            # nothing to do, just pass
            :
        elif [ "$ip6_addr" = "auto" ]; then
            printf '%s\n' "iface $ifname inet6 auto"
        else
            printf '%s\n' "iface $ifname inet6 static"
            printf '%s\n' "    address $ip6_addr/$ip6_prefixlength"
            if [ "$ip6_gateway" != "auto" ]; then
                printf '%s\n' "    gateway $ip6_gateway"
                printf '%s\n' "    accept_ra 0"
            fi
            if [ "$ip6_nameservers" != "auto" ] && [ "$ip6_nameservers" != "disable" ]; then
                printf '%s\n' "    dns-nameservers $ip6_nameservers"
            fi
        fi
    } >> /rootfs/etc/network/interfaces

    # wlan config
    if [ "$ifname" != "eth0" ]; then
        if [ -e /bootfs/config/wpa_supplicant.conf ]; then
            # copy the installer version of `wpa_supplicant.conf`
            cp /bootfs/config/wpa_supplicant.conf /rootfs/etc/wpa_supplicant/
            printf '%s\n' "    wpa-conf /etc/wpa_supplicant/wpa_supplicant.conf"	>> /rootfs/etc/network/interfaces
        fi
    fi

    if [ "${disable_predictable_nin}" = "1" ]; then
        # as described here: https://www.freedesktop.org/wiki/Software/systemd/PredictableNetworkInterfaceNames
        # adding net.ifnames=0 to /boot/cmdline and disabling the persistent-net-generator.rules
        cmdline="${cmdline} net.ifnames=0"
        ln -s /dev/null /rootfs/etc/udev/rules.d/75-persistent-net-generator.rules
    fi

    # copy resolver configuration into rootfs, to be used for remainder of installation
    # will be overwritten by resolvconf when the system is rebooted
    cp /etc/resolv.conf /rootfs/run/resolvconf

    # copy blacklist for rtl8192cu into rootfs; use original Realtek drivers instead
    cp /etc/modprobe.d/blacklist-native-rtl8192.conf /rootfs/etc/modprobe.d/

    log_msg_end "OK"
else
    log_msg_end "  Not configuring network settings in 'base' preset."
fi

# enable serial console on installed system
log_msg_start "  Enabling serial console... "
touch /rootfs/etc/inittab
{
    printf '%s\n' "#Spawn a getty on Raspberry Pi serial line"
    printf '%s\n' "T0:23:respawn:/sbin/getty -L ttyAMA0 115200 vt100"
} >> /rootfs/etc/inittab
log_msg_end "OK"

# set timezone and reconfigure tzdata package
if [ -f "/rootfs/usr/share/zoneinfo/$timezone" ] ; then
    log_msg_start "  Configuring tzdata, setting timezone to $timezone... "
    chroot /rootfs ln -sf /usr/share/zoneinfo/$timezone /etc/localtime
    chroot /rootfs /usr/sbin/dpkg-reconfigure -f noninteractive tzdata 1>/dev/null 2>&1
    if [ $? -eq 0 ]; then
        log_msg_end "OK"
    else
        log_msg_end "FAILED !"
    fi
else
    log_msg "Invalid timezone '$timezone', so not (re-)configuring tzdata!"
fi

# generate locale data
if [ "$locales" != "" ]; then
    log_msg "  Enabling locales... "
    for locale in $locales; do
        log_msg_start "    $locale... "
        if [ -f /rootfs/etc/locale.gen ] && [ "$(grep -c "$locale" /rootfs/etc/locale.gen)" -gt 0 ]; then
            sed -i "s/^# \($locale .*\)/\1/" /rootfs/etc/locale.gen
            log_msg_end "OK"
        else
            log_msg_end "NOT found!"
        fi
    done
    log_msg "  Enabling locales completed."
    if [ -x /rootfs/usr/sbin/locale-gen ] ; then
        chroot /rootfs /usr/sbin/locale-gen | sed 's/^/  /'
        if [ $? -ne 0 ]; then
            log_msg "  ERROR while generating locales !"
        fi
    else
        log_msg "Not generating locales as the 'locales' package isn't installed !"
    fi
fi

# set system default locale
if [ "$system_default_locale" != "" ] ; then
    if [ -x /rootfs/usr/sbin/update-locale ] ; then
        log_msg_start "  Setting system default locale... "
        chroot /rootfs /usr/sbin/update-locale LANG="$system_default_locale" 1>/dev/null 2>&1
        if [ $? -eq 0 ]; then
            log_msg_end "OK"
        else
            log_msg_end "FAILED !"
        fi
    else
        log_msg "NOT setting system default locale as the 'locale' package isn't installed !"
    fi
fi

log_msg ""

# there is no hw clock on rpi
printf '%s\n' "HWCLOCKACCESS=no" >> /rootfs/etc/default/hwclock || fail


# copy apt's sources.list to the target system
log_msg "Configuring apt:"
log_msg_start "  Copying raspbian repo to sources.list... "
cp /rootfs/boot/config/apt/sources.list /rootfs/etc/apt/sources.list || fail
log_msg_end "OK"
log_msg_start "  Replacing __RELEASE__ with $release... "
sed -i "s/__RELEASE__/$release/" /rootfs/etc/apt/sources.list
# if __RELEASE__ is still present, something went wrong
if grep -l '__RELEASE__' /rootfs/etc/apt/sources.list >/dev/null ; then
    log_msg_end "FAILED"
else
    log_msg_end "OK"
fi

log_msg "  Adding raspberrypi.org gpg key to apt-key."
chroot /rootfs /usr/bin/apt-key add 1>/dev/null 2>&1 < /usr/share/keyrings/raspberrypi.gpg.key

# save the current location so that we can go back to it later on
old_dir=$(pwd)
cd /rootfs/boot/config/apt/ || fail

# iterate through all the *.list files and add them to /etc/apt/sources.list.d
for listfile in ./*.list
do
    if [ "$listfile" != "./sources.list" ] && [ -e "$listfile" ] ; then
        log_msg_start "  Copying $listfile to /etc/apt/sources.list.d/... "
        sed "s/__RELEASE__/$release/g" "$listfile" > "/rootfs/etc/apt/sources.list.d/$listfile" || fail
        log_msg_end "OK"
    fi
done

# iterate through all the *.pref files and add them to /etc/apt/preferences.d
for preffile in ./*.pref
do
    if [ -e "$preffile" ]; then
        log_msg_start "  Copying $preffile to /etc/apt/preferences.d/... "
        sed "s/__RELEASE__/$release/g" "$preffile" > "/rootfs/etc/apt/preferences.d/$preffile" || fail
        log_msg_end "OK"
    fi
done

# iterate through all the *.key files and add them to apt-key
for keyfile in ./*.key
do
    if [ -e "$keyfile" ]; then
        log_msg_start "  Adding key $keyfile to apt."
        chroot /rootfs /usr/bin/apt-key add < "$keyfile" || fail
        log_msg_end "OK"
    fi
done

# iterate through all the *.gpg files and add them to /etc/apt/trusted.gpg.d
for keyring in ./*.gpg
do
    if [ -e "$keyring" ]; then
        log_msg_start "  Copying $keyring to /etc/apt/trusted.gpg.d/... "
        cp "$keyring" "/rootfs/etc/apt/trusted.gpg.d/$keyring" || fail
        log_msg_end "OK"
    fi
done

# return to the old location for the rest of the processing
cd "$old_dir" || fail


log_msg_start "Updating package lists... "
chroot /rootfs /usr/bin/apt-get update 1>/dev/null 2>&1
log_msg_end "OK"

# firmware package can't be installed during cdebootstrap phase, so do so now
log_msg_start "Installing bootloader package (=firmware)... "
chroot /rootfs /usr/bin/apt-get -y install raspberrypi-bootloader-nokernel 1>/dev/null 2>&1
if [ $? -eq 0 ]; then
    log_msg_end "OK"
else
    log_msg_end "FAILED !"
fi

# install firmware for wireless chipset (RPi 3 and Zero W)
if [ "$ifname" != "eth0" ]; then
  log_msg_start "Installing firmware for Broadcom wireless network cards... "
  chroot /rootfs /usr/bin/apt-get -y install firmware-brcm80211 1>/dev/null 2>&1
  if [ $? -eq 0 ]; then
    log_msg_end "OK"
  else
    log_msg_end "FAILED !"
  fi
fi

# install libraspberrypi-bin to provide vcgencmd functionality
log_msg_start "Installing libraspberrypi-bin package (=vcgencmd,raspistill,raspivid,etc)... "
chroot /rootfs /usr/bin/apt-get -y install libraspberrypi-bin 1>/dev/null 2>&1
if [ $? -eq 0 ]; then
    log_msg_end "OK"
else
    log_msg_end "FAILED !"
fi

# (conditionaly) enable hardware watchdog and set up systemd to use it
if [ "${enable_watchdog}" = "1" ]; then
    printf '%s\n' "bcm2708_wdog" >> /rootfs/etc/modules
    sed -i 's/^.*RuntimeWatchdogSec=.*$/RuntimeWatchdogSec=14s/' /rootfs/etc/systemd/system.conf
fi

log_msg "Configuring bootloader to start the installed system..."
mv /rootfs/boot/config.txt /rootfs/boot/config-reinstall.txt

# no kernel-upgrade-script for the time being
# just add the kernel/initramfs lines to /boot/config.txt for now
if [ ! -f /rootfs/boot/config.txt ] ; then
    touch /rootfs/boot/config.txt
fi

for hv in ${hardware_versions}
do
    # find kernel/initramfs version
    # SC2086 is overkill as 'hv' is only a number 0-4
    # SC1083 as it seems to work and changing it seems to dangerous for now
    # TODO: rewrite section so it doesn't have to rely on obscure code.
    # shellcheck disable=SC2086,SC1083
    eval kernel_meta_package=\${kernel_meta_package_${hv}}
    if [ ${kernel_meta_package} != "none" ]
    then
        KERNEL_VERSION=$(sed -n -e "/^Package: ${kernel_meta_package}$/,/Package: /{s/^Depends: .*linux-image-\(.*-rpi2\{0,1\}\).*$/\1/p}" /rootfs/var/lib/dpkg/status)
        log_msg "Adding boot config for kernel version: '${KERNEL_VERSION}'"

        {
            printf '%s\n' "[pi${hv}]"
            printf '%s\n' "kernel=vmlinuz-$KERNEL_VERSION"
            printf '%s\n' "initramfs initrd.img-${KERNEL_VERSION} followkernel"
            if [ "${hv}" = "1" ] ; then
                printf '%s\n' "# to disable DeviceTree, uncomment the next line "
                printf '%s\n' "#device_tree="
            fi
            if [ "${hv}" = "3" ] ; then
                printf '%s\n' "# enable the serial console by enabling this DT overlay"
                printf '%s\n' "#dtoverlay=pi3-miniuart-bt"
                # Only enable UART if the user explicitly sets that option.
                # Enabled UART may break the bootprocess / bluetooth support.
                if [ "${enable_uart}" = "1" ]; then
                  printf '%s\n' "# enable the serial console for the installed system"
                  printf '%s\n' "enable_uart=1"
                fi
            fi
        } >> /rootfs/boot/config.txt

        # set the default kernel file based on the hardware
        case ${hv} in
            2|3) default_kernel_file="kernel7.img" ;;
            *) default_kernel_file="kernel.img" ;;
        esac

        # make sure there is a /boot/kernel.img or /boot/kernel7.img present
        if [ ! -f /rootfs/boot/${default_kernel_file} ] ; then
            log_msg_start "Copying kernel to /boot/${default_kernel_file}... "
            cp -- /rootfs/boot/vmlinuz-"${KERNEL_VERSION}" /rootfs/boot/${default_kernel_file}
            if [ $? -eq 0 ]; then
                log_msg_end "OK"
            else
                log_msg_end "FAILED !"
            fi
        fi
    fi
done

# set gpu_mem if specified in the configuration file
if [ -n "${gpu_mem}" ] ; then
    printf '%s\n' "gpu_mem=${gpu_mem}" >> /rootfs/boot/config.txt
fi

# default cmdline.txt
log_msg_start "Creating default cmdline.txt... "
printf '%s\n' "$cmdline root=$rootpartition rootfstype=$rootfstype rootwait" > /rootfs/boot/cmdline.txt
log_msg_end "OK"

# run post install script if exists
if [ -e /bootfs/post-install.txt ]; then
    log_msg "================================================="
    log_msg "=== Start executing post-install.txt. ==="
    sanitize_inputfile /bootfs/post-install.txt
    # shellcheck disable=SC1091   # external file
    . /bootfs/post-install.txt
    log_msg "=== Finished executing post-install.txt. ==="
    log_msg "================================================="
fi

# modify installed network settings
if [ -f /rootfs/etc/wpa_supplicant/wpa_supplicant.conf ]; then
    if [ "$(grep "iface" /rootfs/etc/network/interfaces | grep -cEv "lo|eth0")" -ne 0 ]; then
        if [ "$(grep -c "wpa[-_]" /rootfs/etc/network/interfaces)" -eq 0 ]; then
            printf '%s\n' "wpa-conf /etc/wpa_supplicant/wpa_supplicant.conf" >> /rootfs/etc/network/interfaces
        fi
    fi
fi

# remove cdebootstrap-helper-rc.d which prevents rc.d scripts from running
log_msg_start "Removing cdebootstrap-helper-rc.d... "
chroot /rootfs /usr/bin/dpkg -r cdebootstrap-helper-rc.d 1>/dev/null 2>&1 || fail
log_msg_end "OK"

log_msg_start "Configuring initramfs... "

# if the root fs type isn't build into the kernel, make sure the module is present in the initramfs
if [ "$(grep -c $rootfstype /rootfs/lib/modules/"$(uname -r)"/modules.builtin)" -eq 0 ]; then
{
    printf '%s\n' "$rootfstype"
} >> /rootfs/etc/initramfs-tools/modules
fi
# if the root fs is on a USB drive, make sure the needed modules are present in initramfs as well
if [ "$usbroot" = "1" ]; then
{
    printf '%s\n' "sd_mod"
    printf '%s\n' "usb-storage"
} >> /rootfs/etc/initramfs-tools/modules
fi
log_msg_end "OK"

# save the current location so that we can go back to it later on
old_dir=$(pwd)
cd /rootfs/boot/config/initramfs-tools/hooks/ || fail

for hook_file in ./*
do
    if [ -f "$hook_file" ]; then
        log_msg_start "Copying '$hook_file' to /etc/initramfs-tools/hooks/..."
        cp "$hook_file" /rootfs/etc/initramfs-tools/hooks/ || fail
        log_msg_end "OK"
    fi
done

# return to the old location for the rest of the processing
cd "$old_dir" || fail

log_msg "Regenerating initramfs... "
chroot /rootfs /usr/sbin/update-initramfs -u || fail
log_msg "Regeneration of initramfs succeeded."

teardown_chroot /rootfs

# save current time if fake-hwclock
log_msg "Saving current time for fake-hwclock..."
sync # synchronize before saving time to make it "more accurate"
date +"%Y-%m-%d %H:%M:%S" > /rootfs/etc/fake-hwclock.data

ENDTIME=$(date +%s)
DURATION=$((ENDTIME - REAL_STARTTIME))
log_msg_start "Installation finished at $(date --date="@$ENDTIME" --utc)"
log_msg_end " and took $((DURATION/60)) min $((DURATION%60)) sec ($DURATION seconds)"

# copy logfile to standard log directory
sleep 1
cp -- $LOGFILE /rootfs/var/log/raspbian-ua-netinst.log
chmod 0640 /rootfs/var/log/raspbian-ua-netinst.log

log_msg_start "Unmounting filesystems... "

umount /rootfs/boot
umount /rootfs
log_msg_end "OK"

case ${final_action} in
    poweroff)
        log_msg_start "Finished! Powering off in 5 seconds..."
        ;;
    halt)
        log_msg_start "Finished! Halting in 5 seconds..."
        ;;
    *)
        log_msg_start "Finished! Rebooting to installed system in 5 seconds..."
        final_action=reboot
esac

for i in $(seq 5 -1 1); do
    sleep 1

    log_msg_inline "$i.. "
done
log_msg_end " now"
${final_action}
